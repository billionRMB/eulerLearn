### euler 第12题

[**Highly divisible triangular number**](http://pe-cn.github.io/12/)

题目描述我就不累述了

这个问题的解决需要依赖于之前学过的线性筛

那么 先说一下什么是素数筛是什么

什么是合数？

>  合数指[自然数](https://baike.baidu.com/item/%E8%87%AA%E7%84%B6%E6%95%B0/385394)中除了能被1和本身整除外，还能被其他数（0除外）[整除](https://baike.baidu.com/item/%E6%95%B4%E9%99%A4/2452641)的数。

**那么，如果有一个n以内的素数表，那么我们就可以筛掉 n --- n * n 以内的所有合数**

只要遍历素数表，把每个素数都 × 2 ，× 3 .....,直到 该素数 × i 的值大于 n * n 的值都标记上就OK了 

比如 直到 2,3,5 那么把 2 × 2， 2 × 3， 2 × 4  ......., 3 × 2， 3 × 3 ，3 × 4 ......, 5 × 2， 5 × 3，......都筛掉

**那么真的吗 ，我们需要证明一下正确性**

可以假设一下有一个m 是 n --- n * n 的 合数，表示为 a * b （a < b)

那么我们可以断定 **a 小于n**  ,这个好理解应该，如果 a,b 都大于n 那么 m  就大于n * n了

如果 m 没有被筛掉可能吗？如果真的没有被筛掉，

说明  1. a 没有出现 2. b 没有出现 

因为前提是已经有了n以内的素数表了，所以 a 一定出现了

且 保证b是从 2 -- n 的就可以都筛掉了 

**接下来的问题是素数表从哪儿获得的？**

简单呢。比如我们知道2以内的素数表就是2，

那么我们就可以获得4以内的素数表，

接下来，那么我们就可以获得16以内的素数表

......

ok 了上代码

```c
/*************************************************************************
	> File Name: 1.c
	> Author:Gin.TaMa 
	> Mail:1137554811@qq.com 
	> Created Time: 2018年12月26日 星期三 17时42分21秒
 ************************************************************************/

#include<stdio.h>
#define max 100

int prime[max + 5] = {0};

void init(){
    for(int i = 2;i < max;i ++){
        if(prime[i])continue;
        prime[++prime[0]] = i;
        for(int j = i * i;j < max ;j+=i){
            prime[j] = 1;
        }
    }
}



int main(){
    init();
    printf("%d\n",prime[0]);
    for(int i = 1;i <= prime[0];i++){
        printf("%d\n",prime[i]);
    }
    return 0;
}

```

